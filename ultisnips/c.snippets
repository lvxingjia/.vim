priority 99
# c
# vim:ft=snippets

# Header
snippet inc "include module" b
#include<${1:module}.h>
endsnippet
snippet include "include file" b
#include"${0:file}"
endsnippet
snippet def "define" b
#define ${0}
endsnippet
snippet ndef "ifndef" b
#ifndef $1
#define ${1:SYMBOL} ${2:value}
#endif /* ifndef $1 */
endsnippet
snippet ifdef "ifdef" b
#ifdef ${1}
	${0:#define }
#endif
endsnippet

snippet mv "main(void)" b
int main(void)
{
	${0:${VISUAL}}
	return 0;
}
endsnippet
snippet main "main()" b
int main(int argc, char *argv[])
{
	${0:${VISUAL}}
	return 0;
}
endsnippet

# Comment
snippet cmt "cmt"
/* ${0} */
endsnippet

# Branch
snippet i "if"
if (${1:condition})
endsnippet
snippet if "if then" b
if (${1:condition}) {
	${0:${VISUAL}}
}
endsnippet
snippet ie "if else" b
if (${1:condition}) {
	${2:${VISUAL}}
} else {
	${3}
}
endsnippet
snippet el "else" b
else {
	${0:${VISUAL}}
}
endsnippet
snippet ei "else if" b
else if(${1:condition}) {
	${0:${VISUAL}}
}
endsnippet

snippet = "val1 or val2" b
= ${1:condition} ? ${2:val1} : ${0:val2}
endsnippet
snippet t "ternary operator" b
${1:condition} ? ${2:exp1} : ${0:exp2}
endsnippet

snippet swi "switch" b
switch (${1:variable}) {
	case ${2:constant} :
		${0}
		break;
}
endsnippet
snippet switch "switch" b
switch (${1:variable}) {
	case ${2:constant} :
		${3}
		break;
	default:
		${0}
}
endsnippet
snippet case "case" b
case ${1:constant} :
	${0}
	break;
endsnippet


# Loop
snippet f "for" b
for (int ${2:i} = 0; $2 < ${1:n}; ${3:++}$2)
endsnippet
snippet for "for loop" b
for (${1}; ${2}; ${3}) {
	${0:${VISUAL}}
}
endsnippet

snippet w "while" b
while (${1:condition})
endsnippet
snippet wh "while loop" b
while (${1:condition}) {
	${0:${VISUAL}}
}
endsnippet
snippet do "do loop" b
do {
	${0:${VISUAL}}
} while (${1:condition});
endsnippet


# Func
snippet fv "void func" b
void ${1:func_name}(${2:void})
{
	${0}
}

endsnippet
snippet fi "int func" b
int ${1:func_name}(${2:void})
{
	${0}
	return 0;
}

endsnippet
snippet sfv "static void func" b
static void ${1:func_name}(${2:void})
{
	${0}
}

endsnippet
snippet fi "int func" b
static int ${1:func_name}(${2:void})
{
	${0}
	return 0;
}

endsnippet
snippet fs "char* func" b
char *${1:func_name}(${2:void})
{
	${0}
	return NULL;
}

endsnippet
snippet sf "def static func" b
static ${1:int} ${2:func_name}(${3:void})
{
	${0}
	return $1;
}

endsnippet
snippet sif "def static inline func" b
static inline ${1:int} ${2:func_name}(${3:void})
{
	${0}
	return $1;
}

endsnippet
snippet fn "def func" b
${1:int} ${2:func_name}(${3:void})
{
	${0}
	return $1;
}

endsnippet
snippet func "func with comment" b
static ${1:int} ${2:func_name}(${3:void})
{
	/*${4:func $2}
	 *Args:`!p
snip.rv = ""
snip >> 1
write_args(3,snip)
`
	 *Return:$1
	 */
	${0}
	return $1;
}

endsnippet


# Struct
snippet s "struct" i
struct 
endsnippet
snippet st "struct" b
struct ${1:StructName} {
	${0}
};

endsnippet
snippet ts "typedef struct" b
typedef struct ${1:StructName} {
	${0}
} ${2};

endsnippet
snippet struct "struct with comment" b
typedef struct ${1:StructName} {
	/*${3:struct StructName}
	 *
	 */
	${0}
} ${2};

endsnippet


# Union
snippet u "union"
union {
	${0}
};
endsnippet
snippet un "union" b
union ${1:unionName} {
	${0}
};

endsnippet
snippet tu "typedef union" b
typedef union ${1:unionName} {
	${0}
} ${2};

endsnippet
snippet union "union with comment" b
typedef union ${1:unionName} {
	/*${3:union unionName}
	 *
	 */
	${0}
} ${2};

endsnippet


# Enum
snippet en "enum" b
enum ${1:ENUM_NAME} {
	${0}
};

endsnippet
snippet te "typedef enum" b
typedef enum ${1:ENUM_NAME} {
	/*${3:struct StructName}
	 *
	 */
	${0}
} ${2};

endsnippet
snippet enum "enum with comment" b
typedef enum ${1:ENUM_NAME} {
	/*${3:struct StructName}
	 *
	 */
	${0}
} ${2};

endsnippet

# Keywords/Symbols
snippet r "return"
return 
endsnippet
snippet rt "return" b
return ${0:res}
endsnippet
snippet td "typedef" b
typedef 
endsnippet
snippet co "const" i
const 
endsnippet
snippet cc "const *const" i
const ${1} *const ${0}
endsnippet
snippet cr "restrict" i
const *restrict 
endsnippet
snippet vol "volatile" i
volatile 
endsnippet
snippet si "static inline" b
static inline 
endsnippet


# Functions
snippet p "printf" b
printf("${0:Hello World.}\n");
endsnippet
snippet pd "printf %d" b
printf("$1: %d\n", ${1:var});
endsnippet
snippet pp "printf %p" b
printf("$1: %p\n", ${1:var});
endsnippet
snippet ps "printf %s" b
printf("*$1: %s\n", ${1:var});
endsnippet

snippet sm "struct malloc"
${1:struct name} *${2:self} = ($1*) malloc(sizeof($1));
${0}
endsnippet
snippet sma "struct malloc(fiexible array)"
${1:struct name} *${2:self} = ($1*) malloc(sizeof($1) + ${3} * sizeof(${4:int}));
${0}
endsnippet
snippet ma "malloc"
($2*) malloc(${1:size} * sizeof(${2:int}));
endsnippet
snippet ca "calloc"
($2*) calloc(${1:size}, sizeof(${2:int}));
endsnippet
# Special
snippet vtbl "VTable" b
struct ${1:Class}Vtbl vtbl = {
	${0:.func = void (*foo)(),}
};
self->vptr = &vtbl;
endsnippet
snippet vp "vptr" i
->vptr->
endsnippet

#============================================================#

global !p


class Arg(object):
	def __init__(self,arg):
		nt = arg.split('=')[0].strip().split(" ")
		self.name = nt[-1] if len(nt) != 1 else nt[0]
		self.type = nt[0] if len(nt) != 1 else 'void'


def write_args(x,snip):
	arglyst = t[x]
	argnames = [Arg(a).name for a in arglyst.split(',') if a]
	argtypes = [Arg(a).type for a in arglyst.split(',') if a]
	if not argnames:
		snip.rv = 'void'
	for idx,n in enumerate(argnames):
		if n == 'void':
			snip.rv = 'void'
		else:
			snip += " *    {0}: {1}.".format(n,argtypes[idx])

endglobal

